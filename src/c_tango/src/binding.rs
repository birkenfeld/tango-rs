/* automatically generated by rust-bindgen */

pub const _SYS_TIME_H: libc::c_uint = 1;
pub const _FEATURES_H: libc::c_uint = 1;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const __USE_ISOC11: libc::c_uint = 1;
pub const __USE_ISOC99: libc::c_uint = 1;
pub const __USE_ISOC95: libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const __USE_POSIX: libc::c_uint = 1;
pub const __USE_POSIX2: libc::c_uint = 1;
pub const __USE_POSIX199309: libc::c_uint = 1;
pub const __USE_POSIX199506: libc::c_uint = 1;
pub const __USE_XOPEN2K: libc::c_uint = 1;
pub const __USE_XOPEN2K8: libc::c_uint = 1;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __USE_MISC: libc::c_uint = 1;
pub const __USE_ATFILE: libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_uint = 0;
pub const _STDC_PREDEF_H: libc::c_uint = 1;
pub const __STDC_IEC_559__: libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_uint = 1;
pub const __STDC_ISO_10646__: libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: libc::c_uint = 1;
pub const __GNU_LIBRARY__: libc::c_uint = 6;
pub const __GLIBC__: libc::c_uint = 2;
pub const __GLIBC_MINOR__: libc::c_uint = 25;
pub const _SYS_CDEFS_H: libc::c_uint = 1;
pub const __glibc_c99_flexarr_available: libc::c_uint = 1;
pub const __WORDSIZE: libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: libc::c_uint = 64;
pub const _BITS_TYPES_H: libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_uint = 1;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const __time_t_defined: libc::c_uint = 1;
pub const __timeval_defined: libc::c_uint = 1;
pub const _SYS_SELECT_H: libc::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: libc::c_uint = 1;
pub const __timespec_defined: libc::c_uint = 1;
pub const FD_SETSIZE: libc::c_uint = 1024;
pub const _STDINT_H: libc::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_uint = 0;
pub const _BITS_WCHAR_H: libc::c_uint = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_uint = 127;
pub const INT16_MAX: libc::c_uint = 32767;
pub const INT32_MAX: libc::c_uint = 2147483647;
pub const UINT8_MAX: libc::c_uint = 255;
pub const UINT16_MAX: libc::c_uint = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_uint = 127;
pub const INT_LEAST16_MAX: libc::c_uint = 32767;
pub const INT_LEAST32_MAX: libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_uint = 255;
pub const UINT_LEAST16_MAX: libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_uint = 127;
pub const INT_FAST16_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_uint = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_uint = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_uint = 0;
pub const WINT_MAX: libc::c_uint = 4294967295;
pub const true_: libc::c_uint = 1;
pub const false_: libc::c_uint = 0;
pub const __bool_true_false_are_defined: libc::c_uint = 1;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> libc::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __itimer_which_t = libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> libc::c_int;
}
extern "C" {
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const libc::c_char, __tvp: *const timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const libc::c_char, __tvp: *const timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: libc::c_int, __tvp: *const timeval) -> libc::c_int;
}
pub type int_least8_t = libc::c_schar;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type TangoDevLong = i32;
pub type TangoDevULong = u32;
pub type TangoDevLong64 = i64;
pub type TangoDevULong64 = u64;
pub const TangoDataType_DEV_VOID: TangoDataType = 0;
pub const TangoDataType_DEV_BOOLEAN: TangoDataType = 1;
pub const TangoDataType_DEV_SHORT: TangoDataType = 2;
pub const TangoDataType_DEV_LONG: TangoDataType = 3;
pub const TangoDataType_DEV_FLOAT: TangoDataType = 4;
pub const TangoDataType_DEV_DOUBLE: TangoDataType = 5;
pub const TangoDataType_DEV_USHORT: TangoDataType = 6;
pub const TangoDataType_DEV_ULONG: TangoDataType = 7;
pub const TangoDataType_DEV_STRING: TangoDataType = 8;
pub const TangoDataType_DEVVAR_CHARARRAY: TangoDataType = 9;
pub const TangoDataType_DEVVAR_SHORTARRAY: TangoDataType = 10;
pub const TangoDataType_DEVVAR_LONGARRAY: TangoDataType = 11;
pub const TangoDataType_DEVVAR_FLOATARRAY: TangoDataType = 12;
pub const TangoDataType_DEVVAR_DOUBLEARRAY: TangoDataType = 13;
pub const TangoDataType_DEVVAR_USHORTARRAY: TangoDataType = 14;
pub const TangoDataType_DEVVAR_ULONGARRAY: TangoDataType = 15;
pub const TangoDataType_DEVVAR_STRINGARRAY: TangoDataType = 16;
pub const TangoDataType_DEVVAR_LONGSTRINGARRAY: TangoDataType = 17;
pub const TangoDataType_DEVVAR_DOUBLESTRINGARRAY: TangoDataType = 18;
pub const TangoDataType_DEV_STATE: TangoDataType = 19;
pub const TangoDataType_CONST_DEV_STRING: TangoDataType = 20;
pub const TangoDataType_DEVVAR_BOOLEANARRAY: TangoDataType = 21;
pub const TangoDataType_DEV_UCHAR: TangoDataType = 22;
pub const TangoDataType_DEV_LONG64: TangoDataType = 23;
pub const TangoDataType_DEV_ULONG64: TangoDataType = 24;
pub const TangoDataType_DEVVAR_LONG64ARRAY: TangoDataType = 25;
pub const TangoDataType_DEVVAR_ULONG64ARRAY: TangoDataType = 26;
pub const TangoDataType_DEV_INT: TangoDataType = 27;
pub const TangoDataType_DEV_ENCODED: TangoDataType = 28;
pub type TangoDataType = libc::c_uint;
pub const TangoDevState_ON: TangoDevState = 0;
pub const TangoDevState_OFF: TangoDevState = 1;
pub const TangoDevState_CLOSE: TangoDevState = 2;
pub const TangoDevState_OPEN: TangoDevState = 3;
pub const TangoDevState_INSERT: TangoDevState = 4;
pub const TangoDevState_EXTRACT: TangoDevState = 5;
pub const TangoDevState_MOVING: TangoDevState = 6;
pub const TangoDevState_STANDBY: TangoDevState = 7;
pub const TangoDevState_FAULT: TangoDevState = 8;
pub const TangoDevState_INIT: TangoDevState = 9;
pub const TangoDevState_RUNNING: TangoDevState = 10;
pub const TangoDevState_ALARM: TangoDevState = 11;
pub const TangoDevState_DISABLE: TangoDevState = 12;
pub const TangoDevState_UNKNOWN: TangoDevState = 13;
pub type TangoDevState = libc::c_uint;
pub const AttrQuality_ATTR_VALID: AttrQuality = 0;
pub const AttrQuality_ATTR_INVALID: AttrQuality = 1;
pub const AttrQuality_ATTR_ALARM: AttrQuality = 2;
pub const AttrQuality_ATTR_CHANGING: AttrQuality = 3;
pub const AttrQuality_ATTR_WARNING: AttrQuality = 4;
pub type AttrQuality = libc::c_uint;
pub const AttrWriteType_READ: AttrWriteType = 0;
pub const AttrWriteType_READ_WITH_WRITE: AttrWriteType = 1;
pub const AttrWriteType_WRITE: AttrWriteType = 2;
pub const AttrWriteType_READ_WRITE: AttrWriteType = 3;
pub type AttrWriteType = libc::c_uint;
pub const AttrDataFormat_SCALAR: AttrDataFormat = 0;
pub const AttrDataFormat_SPECTRUM: AttrDataFormat = 1;
pub const AttrDataFormat_IMAGE: AttrDataFormat = 2;
pub type AttrDataFormat = libc::c_uint;
pub const DispLevel_OPERATOR: DispLevel = 0;
pub const DispLevel_EXPERT: DispLevel = 1;
pub type DispLevel = libc::c_uint;
pub const ErrSeverity_WARN: ErrSeverity = 0;
pub const ErrSeverity_ERR: ErrSeverity = 1;
pub const ErrSeverity_PANIC: ErrSeverity = 2;
pub type ErrSeverity = libc::c_uint;
pub const DevSource_DEV: DevSource = 0;
pub const DevSource_CACHE: DevSource = 1;
pub const DevSource_CACHE_DEV: DevSource = 2;
pub type DevSource = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TangoDevEncoded {
    pub encoded_format: *mut libc::c_char,
    pub encoded_length: u32,
    pub encoded_data: *mut u8,
}
#[test]
fn bindgen_test_layout_TangoDevEncoded() {
    assert_eq!(::std::mem::size_of::<TangoDevEncoded>() , 24usize , concat ! (
               "Size of: " , stringify ! ( TangoDevEncoded ) ));
    assert_eq! (::std::mem::align_of::<TangoDevEncoded>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TangoDevEncoded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoDevEncoded ) ) . encoded_format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoDevEncoded ) ,
                "::" , stringify ! ( encoded_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoDevEncoded ) ) . encoded_length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoDevEncoded ) ,
                "::" , stringify ! ( encoded_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoDevEncoded ) ) . encoded_data as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoDevEncoded ) ,
                "::" , stringify ! ( encoded_data ) ));
}
impl Clone for TangoDevEncoded {
    fn clone(&self) -> Self { *self }
}
impl Default for TangoDevEncoded {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarBoolArray {
    pub length: u32,
    pub sequence: *mut bool,
}
#[test]
fn bindgen_test_layout_VarBoolArray() {
    assert_eq!(::std::mem::size_of::<VarBoolArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarBoolArray ) ));
    assert_eq! (::std::mem::align_of::<VarBoolArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarBoolArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarBoolArray ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarBoolArray ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarBoolArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarBoolArray ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for VarBoolArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarBoolArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarCharArray {
    pub length: u32,
    pub sequence: *mut u8,
}
#[test]
fn bindgen_test_layout_VarCharArray() {
    assert_eq!(::std::mem::size_of::<VarCharArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarCharArray ) ));
    assert_eq! (::std::mem::align_of::<VarCharArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarCharArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarCharArray ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarCharArray ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarCharArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarCharArray ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for VarCharArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarCharArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarShortArray {
    pub length: u32,
    pub sequence: *mut i16,
}
#[test]
fn bindgen_test_layout_VarShortArray() {
    assert_eq!(::std::mem::size_of::<VarShortArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarShortArray ) ));
    assert_eq! (::std::mem::align_of::<VarShortArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarShortArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarShortArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarShortArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarShortArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarShortArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarShortArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarShortArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarUShortArray {
    pub length: u32,
    pub sequence: *mut u16,
}
#[test]
fn bindgen_test_layout_VarUShortArray() {
    assert_eq!(::std::mem::size_of::<VarUShortArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarUShortArray ) ));
    assert_eq! (::std::mem::align_of::<VarUShortArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarUShortArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarUShortArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarUShortArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarUShortArray ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarUShortArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarUShortArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarUShortArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarLongArray {
    pub length: u32,
    pub sequence: *mut TangoDevLong,
}
#[test]
fn bindgen_test_layout_VarLongArray() {
    assert_eq!(::std::mem::size_of::<VarLongArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarLongArray ) ));
    assert_eq! (::std::mem::align_of::<VarLongArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarLongArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongArray ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongArray ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongArray ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for VarLongArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarLongArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarULongArray {
    pub length: u32,
    pub sequence: *mut TangoDevULong,
}
#[test]
fn bindgen_test_layout_VarULongArray() {
    assert_eq!(::std::mem::size_of::<VarULongArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarULongArray ) ));
    assert_eq! (::std::mem::align_of::<VarULongArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarULongArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarULongArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarULongArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarULongArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarULongArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarULongArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarULongArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarLong64Array {
    pub length: u32,
    pub sequence: *mut TangoDevLong64,
}
#[test]
fn bindgen_test_layout_VarLong64Array() {
    assert_eq!(::std::mem::size_of::<VarLong64Array>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarLong64Array ) ));
    assert_eq! (::std::mem::align_of::<VarLong64Array>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarLong64Array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLong64Array ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLong64Array ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLong64Array ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLong64Array ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarLong64Array {
    fn clone(&self) -> Self { *self }
}
impl Default for VarLong64Array {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarULong64Array {
    pub length: u32,
    pub sequence: *mut TangoDevULong64,
}
#[test]
fn bindgen_test_layout_VarULong64Array() {
    assert_eq!(::std::mem::size_of::<VarULong64Array>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarULong64Array ) ));
    assert_eq! (::std::mem::align_of::<VarULong64Array>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VarULong64Array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarULong64Array ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarULong64Array ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarULong64Array ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarULong64Array ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for VarULong64Array {
    fn clone(&self) -> Self { *self }
}
impl Default for VarULong64Array {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarFloatArray {
    pub length: u32,
    pub sequence: *mut f32,
}
#[test]
fn bindgen_test_layout_VarFloatArray() {
    assert_eq!(::std::mem::size_of::<VarFloatArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarFloatArray ) ));
    assert_eq! (::std::mem::align_of::<VarFloatArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarFloatArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarFloatArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarFloatArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarFloatArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarFloatArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarFloatArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarFloatArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarDoubleArray {
    pub length: u32,
    pub sequence: *mut f64,
}
#[test]
fn bindgen_test_layout_VarDoubleArray() {
    assert_eq!(::std::mem::size_of::<VarDoubleArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarDoubleArray ) ));
    assert_eq! (::std::mem::align_of::<VarDoubleArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarDoubleArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleArray ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarDoubleArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarDoubleArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarStringArray {
    pub length: u32,
    pub sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarStringArray() {
    assert_eq!(::std::mem::size_of::<VarStringArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarStringArray ) ));
    assert_eq! (::std::mem::align_of::<VarStringArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarStringArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarStringArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarStringArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarStringArray ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarStringArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarStringArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarStringArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarStateArray {
    pub length: u32,
    pub sequence: *mut TangoDevState,
}
#[test]
fn bindgen_test_layout_VarStateArray() {
    assert_eq!(::std::mem::size_of::<VarStateArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarStateArray ) ));
    assert_eq! (::std::mem::align_of::<VarStateArray>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VarStateArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarStateArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarStateArray ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarStateArray ) ) . sequence as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarStateArray ) , "::"
                , stringify ! ( sequence ) ));
}
impl Clone for VarStateArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarStateArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarEncodedArray {
    pub length: u32,
    pub sequence: *mut TangoDevEncoded,
}
#[test]
fn bindgen_test_layout_VarEncodedArray() {
    assert_eq!(::std::mem::size_of::<VarEncodedArray>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VarEncodedArray ) ));
    assert_eq! (::std::mem::align_of::<VarEncodedArray>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VarEncodedArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarEncodedArray ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarEncodedArray ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarEncodedArray ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarEncodedArray ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for VarEncodedArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarEncodedArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarLongStringArray {
    pub long_length: u32,
    pub long_sequence: *mut TangoDevLong,
    pub string_length: u32,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarLongStringArray() {
    assert_eq!(::std::mem::size_of::<VarLongStringArray>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( VarLongStringArray ) ));
    assert_eq! (::std::mem::align_of::<VarLongStringArray>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VarLongStringArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongStringArray ) ) . long_length as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongStringArray ) ,
                "::" , stringify ! ( long_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongStringArray ) ) . long_sequence as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongStringArray ) ,
                "::" , stringify ! ( long_sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongStringArray ) ) . string_length as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongStringArray ) ,
                "::" , stringify ! ( string_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarLongStringArray ) ) . string_sequence
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VarLongStringArray ) ,
                "::" , stringify ! ( string_sequence ) ));
}
impl Clone for VarLongStringArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarLongStringArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VarDoubleStringArray {
    pub double_length: u32,
    pub double_sequence: *mut f64,
    pub string_length: u32,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarDoubleStringArray() {
    assert_eq!(::std::mem::size_of::<VarDoubleStringArray>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VarDoubleStringArray )
               ));
    assert_eq! (::std::mem::align_of::<VarDoubleStringArray>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VarDoubleStringArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleStringArray ) ) . double_length
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleStringArray )
                , "::" , stringify ! ( double_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleStringArray ) ) .
                double_sequence as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleStringArray )
                , "::" , stringify ! ( double_sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleStringArray ) ) . string_length
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleStringArray )
                , "::" , stringify ! ( string_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VarDoubleStringArray ) ) .
                string_sequence as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VarDoubleStringArray )
                , "::" , stringify ! ( string_sequence ) ));
}
impl Clone for VarDoubleStringArray {
    fn clone(&self) -> Self { *self }
}
impl Default for VarDoubleStringArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union TangoAttributeData {
    pub bool_arr: VarBoolArray,
    pub char_arr: VarCharArray,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    pub state_arr: VarStateArray,
    pub encoded_arr: VarEncodedArray,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_TangoAttributeData() {
    assert_eq!(::std::mem::size_of::<TangoAttributeData>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TangoAttributeData ) ));
    assert_eq! (::std::mem::align_of::<TangoAttributeData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TangoAttributeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . bool_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( bool_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . char_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( char_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . short_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( short_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . ushort_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( ushort_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . long_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( long_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . ulong_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( ulong_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . long64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( long64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . ulong64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( ulong64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . float_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( float_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . double_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( double_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . string_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( string_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . state_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( state_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoAttributeData ) ) . encoded_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoAttributeData ) ,
                "::" , stringify ! ( encoded_arr ) ));
}
impl Clone for TangoAttributeData {
    fn clone(&self) -> Self { *self }
}
impl Default for TangoAttributeData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union TangoCommandData {
    pub bool_val: bool,
    pub short_val: i16,
    pub ushort_val: u16,
    pub long_val: i32,
    pub ulong_val: u32,
    pub float_val: f32,
    pub double_val: f64,
    pub string_val: *mut libc::c_char,
    pub state_val: TangoDevState,
    pub long64_val: TangoDevLong64,
    pub ulong64_val: TangoDevULong64,
    pub bool_arr: VarBoolArray,
    pub char_arr: VarCharArray,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    pub state_arr: VarStateArray,
    pub encoded_val: TangoDevEncoded,
    pub long_string_arr: VarLongStringArray,
    pub double_string_arr: VarDoubleStringArray,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_TangoCommandData() {
    assert_eq!(::std::mem::size_of::<TangoCommandData>() , 32usize , concat !
               ( "Size of: " , stringify ! ( TangoCommandData ) ));
    assert_eq! (::std::mem::align_of::<TangoCommandData>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TangoCommandData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . bool_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( bool_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . short_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( short_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ushort_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ushort_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . long_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( long_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ulong_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ulong_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . float_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( float_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . double_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( double_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . string_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( string_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . state_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( state_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . long64_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( long64_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ulong64_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ulong64_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . bool_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( bool_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . char_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( char_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . short_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( short_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ushort_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ushort_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . long_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( long_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ulong_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ulong_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . long64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( long64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . ulong64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( ulong64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . float_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( float_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . double_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( double_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . string_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( string_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . state_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( state_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . encoded_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( encoded_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . long_string_arr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( long_string_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoCommandData ) ) . double_string_arr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoCommandData ) ,
                "::" , stringify ! ( double_string_arr ) ));
}
impl Clone for TangoCommandData {
    fn clone(&self) -> Self { *self }
}
impl Default for TangoCommandData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union TangoPropertyData {
    pub bool_val: bool,
    pub char_val: u8,
    pub short_val: i16,
    pub ushort_val: u16,
    pub long_val: i32,
    pub ulong_val: u32,
    pub float_val: f32,
    pub double_val: f64,
    pub string_val: *mut libc::c_char,
    pub long64_val: TangoDevLong64,
    pub ulong64_val: TangoDevULong64,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_TangoPropertyData() {
    assert_eq!(::std::mem::size_of::<TangoPropertyData>() , 16usize , concat !
               ( "Size of: " , stringify ! ( TangoPropertyData ) ));
    assert_eq! (::std::mem::align_of::<TangoPropertyData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TangoPropertyData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . bool_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( bool_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . char_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( char_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . short_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( short_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ushort_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ushort_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . long_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( long_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ulong_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ulong_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . float_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( float_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . double_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( double_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . string_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( string_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . long64_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( long64_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ulong64_val as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ulong64_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . short_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( short_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ushort_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ushort_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . long_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( long_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ulong_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ulong_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . long64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( long64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . ulong64_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( ulong64_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . float_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( float_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . double_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( double_arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TangoPropertyData ) ) . string_arr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TangoPropertyData ) ,
                "::" , stringify ! ( string_arr ) ));
}
impl Clone for TangoPropertyData {
    fn clone(&self) -> Self { *self }
}
impl Default for TangoPropertyData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct CommandData {
    pub arg_type: TangoDataType,
    pub cmd_data: TangoCommandData,
}
#[test]
fn bindgen_test_layout_CommandData() {
    assert_eq!(::std::mem::size_of::<CommandData>() , 40usize , concat ! (
               "Size of: " , stringify ! ( CommandData ) ));
    assert_eq! (::std::mem::align_of::<CommandData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CommandData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandData ) ) . arg_type as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandData ) , "::" ,
                stringify ! ( arg_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandData ) ) . cmd_data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandData ) , "::" ,
                stringify ! ( cmd_data ) ));
}
impl Clone for CommandData {
    fn clone(&self) -> Self { *self }
}
impl Default for CommandData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct AttributeData {
    pub data_type: TangoDataType,
    pub attr_data: TangoAttributeData,
    pub data_format: AttrDataFormat,
    pub quality: AttrQuality,
    pub nb_read: libc::c_long,
    pub name: *mut libc::c_char,
    pub dim_x: i32,
    pub dim_y: i32,
    pub time_stamp: timeval,
}
#[test]
fn bindgen_test_layout_AttributeData() {
    assert_eq!(::std::mem::size_of::<AttributeData>() , 72usize , concat ! (
               "Size of: " , stringify ! ( AttributeData ) ));
    assert_eq! (::std::mem::align_of::<AttributeData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AttributeData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . data_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( data_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . attr_data as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( attr_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . data_format as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( data_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . quality as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . nb_read as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( nb_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . name as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . dim_x as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( dim_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . dim_y as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( dim_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeData ) ) . time_stamp as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeData ) , "::"
                , stringify ! ( time_stamp ) ));
}
impl Clone for AttributeData {
    fn clone(&self) -> Self { *self }
}
impl Default for AttributeData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AttributeDataList {
    pub length: u32,
    pub sequence: *mut AttributeData,
}
#[test]
fn bindgen_test_layout_AttributeDataList() {
    assert_eq!(::std::mem::size_of::<AttributeDataList>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AttributeDataList ) ));
    assert_eq! (::std::mem::align_of::<AttributeDataList>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AttributeDataList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeDataList ) ) . length as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeDataList ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeDataList ) ) . sequence as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeDataList ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for AttributeDataList {
    fn clone(&self) -> Self { *self }
}
impl Default for AttributeDataList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DevFailed {
    pub desc: *mut libc::c_char,
    pub reason: *mut libc::c_char,
    pub origin: *mut libc::c_char,
    pub severity: ErrSeverity,
}
#[test]
fn bindgen_test_layout_DevFailed() {
    assert_eq!(::std::mem::size_of::<DevFailed>() , 32usize , concat ! (
               "Size of: " , stringify ! ( DevFailed ) ));
    assert_eq! (::std::mem::align_of::<DevFailed>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DevFailed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DevFailed ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DevFailed ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DevFailed ) ) . reason as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DevFailed ) , "::" ,
                stringify ! ( reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DevFailed ) ) . origin as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DevFailed ) , "::" ,
                stringify ! ( origin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DevFailed ) ) . severity as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( DevFailed ) , "::" ,
                stringify ! ( severity ) ));
}
impl Clone for DevFailed {
    fn clone(&self) -> Self { *self }
}
impl Default for DevFailed {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ErrorStack {
    pub length: u32,
    pub sequence: *mut DevFailed,
}
#[test]
fn bindgen_test_layout_ErrorStack() {
    assert_eq!(::std::mem::size_of::<ErrorStack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ErrorStack ) ));
    assert_eq! (::std::mem::align_of::<ErrorStack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ErrorStack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorStack ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorStack ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ErrorStack ) ) . sequence as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ErrorStack ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for ErrorStack {
    fn clone(&self) -> Self { *self }
}
impl Default for ErrorStack {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CommandInfo {
    pub cmd_name: *mut libc::c_char,
    pub cmd_tag: i32,
    pub in_type: i32,
    pub out_type: i32,
    pub in_type_desc: *mut libc::c_char,
    pub out_type_desc: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout_CommandInfo() {
    assert_eq!(::std::mem::size_of::<CommandInfo>() , 48usize , concat ! (
               "Size of: " , stringify ! ( CommandInfo ) ));
    assert_eq! (::std::mem::align_of::<CommandInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( CommandInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . cmd_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( cmd_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . cmd_tag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( cmd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . in_type as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( in_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . out_type as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( out_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . in_type_desc as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( in_type_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . out_type_desc as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( out_type_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfo ) ) . disp_level as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfo ) , "::" ,
                stringify ! ( disp_level ) ));
}
impl Clone for CommandInfo {
    fn clone(&self) -> Self { *self }
}
impl Default for CommandInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CommandInfoList {
    pub length: u32,
    pub sequence: *mut CommandInfo,
}
#[test]
fn bindgen_test_layout_CommandInfoList() {
    assert_eq!(::std::mem::size_of::<CommandInfoList>() , 16usize , concat ! (
               "Size of: " , stringify ! ( CommandInfoList ) ));
    assert_eq! (::std::mem::align_of::<CommandInfoList>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( CommandInfoList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfoList ) ) . length as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfoList ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const CommandInfoList ) ) . sequence as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( CommandInfoList ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for CommandInfoList {
    fn clone(&self) -> Self { *self }
}
impl Default for CommandInfoList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AttributeInfo {
    pub name: *mut libc::c_char,
    pub writable: AttrWriteType,
    pub data_format: AttrDataFormat,
    pub data_type: TangoDataType,
    pub max_dim_x: i32,
    pub max_dim_y: i32,
    pub description: *mut libc::c_char,
    pub label: *mut libc::c_char,
    pub unit: *mut libc::c_char,
    pub standard_unit: *mut libc::c_char,
    pub display_unit: *mut libc::c_char,
    pub format: *mut libc::c_char,
    pub min_value: *mut libc::c_char,
    pub max_value: *mut libc::c_char,
    pub min_alarm: *mut libc::c_char,
    pub max_alarm: *mut libc::c_char,
    pub writable_attr_name: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout_AttributeInfo() {
    assert_eq!(::std::mem::size_of::<AttributeInfo>() , 128usize , concat ! (
               "Size of: " , stringify ! ( AttributeInfo ) ));
    assert_eq! (::std::mem::align_of::<AttributeInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( AttributeInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . writable as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( writable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . data_format as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( data_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . data_type as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( data_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . max_dim_x as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( max_dim_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . max_dim_y as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( max_dim_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . description as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . label as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . unit as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . standard_unit as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( standard_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . display_unit as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( display_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . format as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . min_value as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( min_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . max_value as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( max_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . min_alarm as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( min_alarm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . max_alarm as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( max_alarm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . writable_attr_name as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( writable_attr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfo ) ) . disp_level as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfo ) , "::"
                , stringify ! ( disp_level ) ));
}
impl Clone for AttributeInfo {
    fn clone(&self) -> Self { *self }
}
impl Default for AttributeInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AttributeInfoList {
    pub length: u32,
    pub sequence: *mut AttributeInfo,
}
#[test]
fn bindgen_test_layout_AttributeInfoList() {
    assert_eq!(::std::mem::size_of::<AttributeInfoList>() , 16usize , concat !
               ( "Size of: " , stringify ! ( AttributeInfoList ) ));
    assert_eq! (::std::mem::align_of::<AttributeInfoList>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( AttributeInfoList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfoList ) ) . length as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfoList ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const AttributeInfoList ) ) . sequence as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( AttributeInfoList ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for AttributeInfoList {
    fn clone(&self) -> Self { *self }
}
impl Default for AttributeInfoList {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct DbDatum {
    pub property_name: *mut libc::c_char,
    pub data_type: TangoDataType,
    pub prop_data: TangoPropertyData,
    pub is_empty: bool,
    pub wrong_data_type: bool,
}
#[test]
fn bindgen_test_layout_DbDatum() {
    assert_eq!(::std::mem::size_of::<DbDatum>() , 40usize , concat ! (
               "Size of: " , stringify ! ( DbDatum ) ));
    assert_eq! (::std::mem::align_of::<DbDatum>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DbDatum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbDatum ) ) . property_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DbDatum ) , "::" ,
                stringify ! ( property_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbDatum ) ) . data_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DbDatum ) , "::" ,
                stringify ! ( data_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbDatum ) ) . prop_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( DbDatum ) , "::" ,
                stringify ! ( prop_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbDatum ) ) . is_empty as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( DbDatum ) , "::" ,
                stringify ! ( is_empty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbDatum ) ) . wrong_data_type as * const
                _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( DbDatum ) , "::" ,
                stringify ! ( wrong_data_type ) ));
}
impl Clone for DbDatum {
    fn clone(&self) -> Self { *self }
}
impl Default for DbDatum {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DbData {
    pub length: u32,
    pub sequence: *mut DbDatum,
}
#[test]
fn bindgen_test_layout_DbData() {
    assert_eq!(::std::mem::size_of::<DbData>() , 16usize , concat ! (
               "Size of: " , stringify ! ( DbData ) ));
    assert_eq! (::std::mem::align_of::<DbData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( DbData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbData ) ) . length as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( DbData ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const DbData ) ) . sequence as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( DbData ) , "::" ,
                stringify ! ( sequence ) ));
}
impl Clone for DbData {
    fn clone(&self) -> Self { *self }
}
impl Default for DbData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tango_create_device_proxy(dev_name: *mut libc::c_char,
                                     proxy: *mut *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_proxy(proxy: *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_timeout_millis(proxy: *mut libc::c_void,
                                    millis: libc::c_int) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_timeout_millis(proxy: *mut libc::c_void,
                                    millis: *mut libc::c_int)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_source(proxy: *mut libc::c_void, source: DevSource)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_source(proxy: *mut libc::c_void, source: *mut DevSource)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_lock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_unlock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked(proxy: *mut libc::c_void, is_locked: *mut bool)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked_by_me(proxy: *mut libc::c_void,
                                 is_locked_by_me: *mut bool)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_locking_status(proxy: *mut libc::c_void,
                                lock_status: *mut *mut libc::c_char)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_query(proxy: *mut libc::c_void,
                               cmd_name: *mut libc::c_char,
                               cmd_info: *mut CommandInfo) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_list_query(proxy: *mut libc::c_void,
                                    cmd_info_list: *mut CommandInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_inout(proxy: *mut libc::c_void,
                               cmd_name: *mut libc::c_char,
                               argin: *mut CommandData,
                               argout: *mut CommandData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_CommandData(command_data: *mut CommandData);
}
extern "C" {
    pub fn tango_free_CommandInfo(command_info: *mut CommandInfo);
}
extern "C" {
    pub fn tango_free_CommandInfoList(command_info_list:
                                          *mut CommandInfoList);
}
extern "C" {
    pub fn tango_get_attribute_list(proxy: *mut libc::c_void,
                                    attr_names: *mut VarStringArray)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_attribute_config(proxy: *mut libc::c_void,
                                      attr_names: *mut VarStringArray,
                                      attr_info_list: *mut AttributeInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_attribute_list_query(proxy: *mut libc::c_void,
                                      attr_info_list: *mut AttributeInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attribute(proxy: *mut libc::c_void,
                                attr_name: *mut libc::c_char,
                                argout: *mut AttributeData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attribute(proxy: *mut libc::c_void,
                                 argin: *mut AttributeData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attributes(proxy: *mut libc::c_void,
                                 attr_names: *mut VarStringArray,
                                 argout: *mut AttributeDataList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attributes(proxy: *mut libc::c_void,
                                  argin: *mut AttributeDataList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_AttributeData(attribute_data: *mut AttributeData);
}
extern "C" {
    pub fn tango_free_AttributeDataList(attribute_data_list:
                                            *mut AttributeDataList);
}
extern "C" {
    pub fn tango_free_VarStringArray(string_arr: *mut VarStringArray);
}
extern "C" {
    pub fn tango_free_AttributeInfoList(attribute_info_list:
                                            *mut AttributeInfoList);
}
extern "C" {
    pub fn tango_free_ErrorStack(error_stack: *mut ErrorStack);
}
extern "C" {
    pub fn tango_create_database_proxy(db_proxy: *mut *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_database_proxy(db_proxy: *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported(db_proxy: *mut libc::c_void,
                                     name_filter: *mut libc::c_char,
                                     dev_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported_for_class(db_proxy: *mut libc::c_void,
                                               class_name: *mut libc::c_char,
                                               dev_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_list(db_proxy: *mut libc::c_void,
                                 name_filter: *mut libc::c_char,
                                 obj_list: *mut DbDatum) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_property_list(db_proxy: *mut libc::c_void,
                                          obj_name: *mut libc::c_char,
                                          name_filter: *mut libc::c_char,
                                          prop_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_property(db_proxy: *mut libc::c_void,
                              obj_name: *mut libc::c_char,
                              prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_property(db_proxy: *mut libc::c_void,
                              obj_name: *mut libc::c_char,
                              prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_property(db_proxy: *mut libc::c_void,
                                 obj_name: *mut libc::c_char,
                                 prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_property(dev_proxy: *mut libc::c_void,
                                     prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_device_property(dev_proxy: *mut libc::c_void,
                                     prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_property(dev_proxy: *mut libc::c_void,
                                        prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_DbDatum(db_datum: *mut DbDatum);
}
extern "C" {
    pub fn tango_free_DbData(db_data: *mut DbData);
}
