/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _SYS_TIME_H: libc::c_uint = 1;
pub const _FEATURES_H: libc::c_uint = 1;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const __USE_ISOC11: libc::c_uint = 1;
pub const __USE_ISOC99: libc::c_uint = 1;
pub const __USE_ISOC95: libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const __USE_POSIX: libc::c_uint = 1;
pub const __USE_POSIX2: libc::c_uint = 1;
pub const __USE_POSIX199309: libc::c_uint = 1;
pub const __USE_POSIX199506: libc::c_uint = 1;
pub const __USE_XOPEN2K: libc::c_uint = 1;
pub const __USE_XOPEN2K8: libc::c_uint = 1;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __USE_MISC: libc::c_uint = 1;
pub const __USE_ATFILE: libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_uint = 0;
pub const _STDC_PREDEF_H: libc::c_uint = 1;
pub const __STDC_IEC_559__: libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_uint = 1;
pub const __STDC_ISO_10646__: libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: libc::c_uint = 1;
pub const __GNU_LIBRARY__: libc::c_uint = 6;
pub const __GLIBC__: libc::c_uint = 2;
pub const __GLIBC_MINOR__: libc::c_uint = 23;
pub const _SYS_CDEFS_H: libc::c_uint = 1;
pub const __WORDSIZE: libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: libc::c_uint = 64;
pub const _BITS_TYPES_H: libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_uint = 1;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const __time_t_defined: libc::c_uint = 1;
pub const _STRUCT_TIMEVAL: libc::c_uint = 1;
pub const _SYS_SELECT_H: libc::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: libc::c_uint = 1;
pub const __timespec_defined: libc::c_uint = 1;
pub const FD_SETSIZE: libc::c_uint = 1024;
pub const true_: libc::c_uint = 1;
pub const false_: libc::c_uint = 0;
pub const __bool_true_false_are_defined: libc::c_uint = 1;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_char;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 4usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_1 as __fsid_t;
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 8usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_2 as __sigset_t;
pub use self::__sigset_t as sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::std::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 8usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_3 as fd_set;
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize);
    assert_eq!(::std::mem::align_of::<timezone>() , 4usize);
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> libc::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = __itimer_which(0);
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = __itimer_which(1);
pub const __itimer_which_ITIMER_PROF: __itimer_which = __itimer_which(2);
impl ::std::ops::BitOr<__itimer_which> for __itimer_which {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { __itimer_which(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct __itimer_which(pub u32);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize);
    assert_eq!(::std::mem::align_of::<itimerval>() , 8usize);
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __itimer_which_t = libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> libc::c_int;
}
extern "C" {
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const libc::c_char, __tvp: *mut timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const libc::c_char, __tvp: *mut timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: libc::c_int, __tvp: *mut timeval) -> libc::c_int;
}
pub type TangoDevLong = libc::c_int;
pub type TangoDevULong = libc::c_uint;
pub type TangoDevLong64 = libc::c_long;
pub type TangoDevULong64 = libc::c_ulong;
pub const DEV_VOID: _bindgen_ty_4 = _bindgen_ty_4(0);
pub const DEV_BOOLEAN: _bindgen_ty_4 = _bindgen_ty_4(1);
pub const DEV_SHORT: _bindgen_ty_4 = _bindgen_ty_4(2);
pub const DEV_LONG: _bindgen_ty_4 = _bindgen_ty_4(3);
pub const DEV_FLOAT: _bindgen_ty_4 = _bindgen_ty_4(4);
pub const DEV_DOUBLE: _bindgen_ty_4 = _bindgen_ty_4(5);
pub const DEV_USHORT: _bindgen_ty_4 = _bindgen_ty_4(6);
pub const DEV_ULONG: _bindgen_ty_4 = _bindgen_ty_4(7);
pub const DEV_STRING: _bindgen_ty_4 = _bindgen_ty_4(8);
pub const DEVVAR_CHARARRAY: _bindgen_ty_4 = _bindgen_ty_4(9);
pub const DEVVAR_SHORTARRAY: _bindgen_ty_4 = _bindgen_ty_4(10);
pub const DEVVAR_LONGARRAY: _bindgen_ty_4 = _bindgen_ty_4(11);
pub const DEVVAR_FLOATARRAY: _bindgen_ty_4 = _bindgen_ty_4(12);
pub const DEVVAR_DOUBLEARRAY: _bindgen_ty_4 = _bindgen_ty_4(13);
pub const DEVVAR_USHORTARRAY: _bindgen_ty_4 = _bindgen_ty_4(14);
pub const DEVVAR_ULONGARRAY: _bindgen_ty_4 = _bindgen_ty_4(15);
pub const DEVVAR_STRINGARRAY: _bindgen_ty_4 = _bindgen_ty_4(16);
pub const DEVVAR_LONGSTRINGARRAY: _bindgen_ty_4 = _bindgen_ty_4(17);
pub const DEVVAR_DOUBLESTRINGARRAY: _bindgen_ty_4 = _bindgen_ty_4(18);
pub const DEV_STATE: _bindgen_ty_4 = _bindgen_ty_4(19);
pub const CONST_DEV_STRING: _bindgen_ty_4 = _bindgen_ty_4(20);
pub const DEVVAR_BOOLEANARRAY: _bindgen_ty_4 = _bindgen_ty_4(21);
pub const DEV_UCHAR: _bindgen_ty_4 = _bindgen_ty_4(22);
pub const DEV_LONG64: _bindgen_ty_4 = _bindgen_ty_4(23);
pub const DEV_ULONG64: _bindgen_ty_4 = _bindgen_ty_4(24);
pub const DEVVAR_LONG64ARRAY: _bindgen_ty_4 = _bindgen_ty_4(25);
pub const DEVVAR_ULONG64ARRAY: _bindgen_ty_4 = _bindgen_ty_4(26);
pub const DEV_INT: _bindgen_ty_4 = _bindgen_ty_4(27);
pub const DEV_ENCODED: _bindgen_ty_4 = _bindgen_ty_4(28);
impl ::std::ops::BitOr<_bindgen_ty_4> for _bindgen_ty_4 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_4(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_4(pub u32);
pub use self::_bindgen_ty_4 as TangoDataType;
pub const ON: _bindgen_ty_5 = _bindgen_ty_5(0);
pub const OFF: _bindgen_ty_5 = _bindgen_ty_5(1);
pub const CLOSE: _bindgen_ty_5 = _bindgen_ty_5(2);
pub const OPEN: _bindgen_ty_5 = _bindgen_ty_5(3);
pub const INSERT: _bindgen_ty_5 = _bindgen_ty_5(4);
pub const EXTRACT: _bindgen_ty_5 = _bindgen_ty_5(5);
pub const MOVING: _bindgen_ty_5 = _bindgen_ty_5(6);
pub const STANDBY: _bindgen_ty_5 = _bindgen_ty_5(7);
pub const FAULT: _bindgen_ty_5 = _bindgen_ty_5(8);
pub const INIT: _bindgen_ty_5 = _bindgen_ty_5(9);
pub const RUNNING: _bindgen_ty_5 = _bindgen_ty_5(10);
pub const ALARM: _bindgen_ty_5 = _bindgen_ty_5(11);
pub const DISABLE: _bindgen_ty_5 = _bindgen_ty_5(12);
pub const UNKNOWN: _bindgen_ty_5 = _bindgen_ty_5(13);
impl ::std::ops::BitOr<_bindgen_ty_5> for _bindgen_ty_5 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_5(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_5(pub u32);
pub use self::_bindgen_ty_5 as TangoDevState;
pub const ATTR_VALID: _bindgen_ty_6 = _bindgen_ty_6(0);
pub const ATTR_INVALID: _bindgen_ty_6 = _bindgen_ty_6(1);
pub const ATTR_ALARM: _bindgen_ty_6 = _bindgen_ty_6(2);
pub const ATTR_CHANGING: _bindgen_ty_6 = _bindgen_ty_6(3);
pub const ATTR_WARNING: _bindgen_ty_6 = _bindgen_ty_6(4);
impl ::std::ops::BitOr<_bindgen_ty_6> for _bindgen_ty_6 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_6(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_6(pub u32);
pub use self::_bindgen_ty_6 as AttrQuality;
pub const READ: _bindgen_ty_7 = _bindgen_ty_7(0);
pub const READ_WITH_WRITE: _bindgen_ty_7 = _bindgen_ty_7(1);
pub const WRITE: _bindgen_ty_7 = _bindgen_ty_7(2);
pub const READ_WRITE: _bindgen_ty_7 = _bindgen_ty_7(3);
impl ::std::ops::BitOr<_bindgen_ty_7> for _bindgen_ty_7 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_7(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_7(pub u32);
pub use self::_bindgen_ty_7 as AttrWriteType;
pub const SCALAR: _bindgen_ty_8 = _bindgen_ty_8(0);
pub const SPECTRUM: _bindgen_ty_8 = _bindgen_ty_8(1);
pub const IMAGE: _bindgen_ty_8 = _bindgen_ty_8(2);
impl ::std::ops::BitOr<_bindgen_ty_8> for _bindgen_ty_8 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_8(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_8(pub u32);
pub use self::_bindgen_ty_8 as AttrDataFormat;
pub const OPERATOR: _bindgen_ty_9 = _bindgen_ty_9(0);
pub const EXPERT: _bindgen_ty_9 = _bindgen_ty_9(1);
impl ::std::ops::BitOr<_bindgen_ty_9> for _bindgen_ty_9 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_9(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_9(pub u32);
pub use self::_bindgen_ty_9 as DispLevel;
pub const WARN: _bindgen_ty_10 = _bindgen_ty_10(0);
pub const ERR: _bindgen_ty_10 = _bindgen_ty_10(1);
pub const PANIC: _bindgen_ty_10 = _bindgen_ty_10(2);
impl ::std::ops::BitOr<_bindgen_ty_10> for _bindgen_ty_10 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_10(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_10(pub u32);
pub use self::_bindgen_ty_10 as ErrSeverity;
pub const DEV: _bindgen_ty_11 = _bindgen_ty_11(0);
pub const CACHE: _bindgen_ty_11 = _bindgen_ty_11(1);
pub const CACHE_DEV: _bindgen_ty_11 = _bindgen_ty_11(2);
impl ::std::ops::BitOr<_bindgen_ty_11> for _bindgen_ty_11 {
    type
    Output
    =
    Self;
    #[inline]
    fn bitor(self, other: Self) -> Self { _bindgen_ty_11(self.0 | other.0) }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct _bindgen_ty_11(pub u32);
pub use self::_bindgen_ty_11 as DevSource;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    pub encoded_format: *mut libc::c_char,
    pub encoded_length: libc::c_uint,
    pub encoded_data: *mut libc::c_uchar,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 8usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_12 as TangoDevEncoded;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_13 {
    pub length: libc::c_uint,
    pub sequence: *mut bool,
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13>() , 8usize);
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_13 as VarBoolArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14 {
    pub length: libc::c_uint,
    pub sequence: *mut libc::c_uchar,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 8usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_14 as VarCharArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    pub length: libc::c_uint,
    pub sequence: *mut libc::c_short,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 8usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_15 as VarShortArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub length: libc::c_uint,
    pub sequence: *mut libc::c_ushort,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 8usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_16 as VarUShortArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevLong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 8usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_17 as VarLongArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevULong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 8usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_18 as VarULongArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevLong64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_19>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_19>() , 8usize);
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_19 as VarLong64Array;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_20 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevULong64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_20() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_20>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_20>() , 8usize);
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_20 as VarULong64Array;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_21 {
    pub length: libc::c_uint,
    pub sequence: *mut f32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_21() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_21>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_21>() , 8usize);
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_21 as VarFloatArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_22 {
    pub length: libc::c_uint,
    pub sequence: *mut f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_22() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_22>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_22>() , 8usize);
}
impl Clone for _bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_22 as VarDoubleArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_23 {
    pub length: libc::c_uint,
    pub sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_23() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_23>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_23>() , 8usize);
}
impl Clone for _bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_23 as VarStringArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_24 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevState,
}
#[test]
fn bindgen_test_layout__bindgen_ty_24() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_24>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_24>() , 8usize);
}
impl Clone for _bindgen_ty_24 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_24 as VarStateArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_25 {
    pub length: libc::c_uint,
    pub sequence: *mut TangoDevEncoded,
}
#[test]
fn bindgen_test_layout__bindgen_ty_25() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_25>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_25>() , 8usize);
}
impl Clone for _bindgen_ty_25 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_25 as VarEncodedArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_26 {
    pub long_length: libc::c_uint,
    pub long_sequence: *mut TangoDevLong,
    pub string_length: libc::c_uint,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_26() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_26>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_26>() , 8usize);
}
impl Clone for _bindgen_ty_26 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_26 as VarLongStringArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_27 {
    pub double_length: libc::c_uint,
    pub double_sequence: *mut f64,
    pub string_length: libc::c_uint,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_27() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_27>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_27>() , 8usize);
}
impl Clone for _bindgen_ty_27 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_27 as VarDoubleStringArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_28 {
    pub bool_arr: __BindgenUnionField<VarBoolArray>,
    pub char_arr: __BindgenUnionField<VarCharArray>,
    pub short_arr: __BindgenUnionField<VarShortArray>,
    pub ushort_arr: __BindgenUnionField<VarUShortArray>,
    pub long_arr: __BindgenUnionField<VarLongArray>,
    pub ulong_arr: __BindgenUnionField<VarULongArray>,
    pub long64_arr: __BindgenUnionField<VarLong64Array>,
    pub ulong64_arr: __BindgenUnionField<VarULong64Array>,
    pub float_arr: __BindgenUnionField<VarFloatArray>,
    pub double_arr: __BindgenUnionField<VarDoubleArray>,
    pub string_arr: __BindgenUnionField<VarStringArray>,
    pub state_arr: __BindgenUnionField<VarStateArray>,
    pub encoded_arr: __BindgenUnionField<VarEncodedArray>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_28() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_28>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_28>() , 8usize);
}
impl Clone for _bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_28 as TangoAttributeData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_29 {
    pub bool_val: __BindgenUnionField<bool>,
    pub short_val: __BindgenUnionField<libc::c_short>,
    pub ushort_val: __BindgenUnionField<libc::c_ushort>,
    pub long_val: __BindgenUnionField<libc::c_int>,
    pub ulong_val: __BindgenUnionField<libc::c_uint>,
    pub float_val: __BindgenUnionField<f32>,
    pub double_val: __BindgenUnionField<f64>,
    pub string_val: __BindgenUnionField<*mut libc::c_char>,
    pub state_val: __BindgenUnionField<TangoDevState>,
    pub long64_val: __BindgenUnionField<TangoDevLong64>,
    pub ulong64_val: __BindgenUnionField<TangoDevULong64>,
    pub bool_arr: __BindgenUnionField<VarBoolArray>,
    pub char_arr: __BindgenUnionField<VarCharArray>,
    pub short_arr: __BindgenUnionField<VarShortArray>,
    pub ushort_arr: __BindgenUnionField<VarUShortArray>,
    pub long_arr: __BindgenUnionField<VarLongArray>,
    pub ulong_arr: __BindgenUnionField<VarULongArray>,
    pub long64_arr: __BindgenUnionField<VarLong64Array>,
    pub ulong64_arr: __BindgenUnionField<VarULong64Array>,
    pub float_arr: __BindgenUnionField<VarFloatArray>,
    pub double_arr: __BindgenUnionField<VarDoubleArray>,
    pub string_arr: __BindgenUnionField<VarStringArray>,
    pub state_arr: __BindgenUnionField<VarStateArray>,
    pub encoded_val: __BindgenUnionField<TangoDevEncoded>,
    pub long_string_arr: __BindgenUnionField<VarLongStringArray>,
    pub double_string_arr: __BindgenUnionField<VarDoubleStringArray>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_29() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_29>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_29>() , 8usize);
}
impl Clone for _bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_29 as TangoCommandData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_30 {
    pub bool_val: __BindgenUnionField<bool>,
    pub char_val: __BindgenUnionField<libc::c_uchar>,
    pub short_val: __BindgenUnionField<libc::c_short>,
    pub ushort_val: __BindgenUnionField<libc::c_ushort>,
    pub long_val: __BindgenUnionField<libc::c_int>,
    pub ulong_val: __BindgenUnionField<libc::c_uint>,
    pub float_val: __BindgenUnionField<f32>,
    pub double_val: __BindgenUnionField<f64>,
    pub string_val: __BindgenUnionField<*mut libc::c_char>,
    pub long64_val: __BindgenUnionField<TangoDevLong64>,
    pub ulong64_val: __BindgenUnionField<TangoDevULong64>,
    pub short_arr: __BindgenUnionField<VarShortArray>,
    pub ushort_arr: __BindgenUnionField<VarUShortArray>,
    pub long_arr: __BindgenUnionField<VarLongArray>,
    pub ulong_arr: __BindgenUnionField<VarULongArray>,
    pub long64_arr: __BindgenUnionField<VarLong64Array>,
    pub ulong64_arr: __BindgenUnionField<VarULong64Array>,
    pub float_arr: __BindgenUnionField<VarFloatArray>,
    pub double_arr: __BindgenUnionField<VarDoubleArray>,
    pub string_arr: __BindgenUnionField<VarStringArray>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_30>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_30>() , 8usize);
}
impl Clone for _bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_30 as TangoPropertyData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_31 {
    pub arg_type: TangoDataType,
    pub cmd_data: TangoCommandData,
}
#[test]
fn bindgen_test_layout__bindgen_ty_31() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_31>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_31>() , 8usize);
}
impl Clone for _bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_31 as CommandData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32 {
    pub data_type: TangoDataType,
    pub attr_data: TangoAttributeData,
    pub data_format: AttrDataFormat,
    pub quality: AttrQuality,
    pub nb_read: libc::c_long,
    pub name: *mut libc::c_char,
    pub dim_x: libc::c_int,
    pub dim_y: libc::c_int,
    pub time_stamp: timeval,
}
#[test]
fn bindgen_test_layout__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32>() , 72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32>() , 8usize);
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_32 as AttributeData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_33 {
    pub length: libc::c_uint,
    pub sequence: *mut AttributeData,
}
#[test]
fn bindgen_test_layout__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_33>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_33>() , 8usize);
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_33 as AttributeDataList;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    pub desc: *mut libc::c_char,
    pub reason: *mut libc::c_char,
    pub origin: *mut libc::c_char,
    pub severity: ErrSeverity,
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 8usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_34 as DevFailed;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub length: libc::c_uint,
    pub sequence: *mut DevFailed,
}
#[test]
fn bindgen_test_layout__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_35>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_35>() , 8usize);
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_35 as ErrorStack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_36 {
    pub cmd_name: *mut libc::c_char,
    pub cmd_tag: libc::c_int,
    pub in_type: libc::c_int,
    pub out_type: libc::c_int,
    pub in_type_desc: *mut libc::c_char,
    pub out_type_desc: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_36>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_36>() , 8usize);
}
impl Clone for _bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_36 as CommandInfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_37 {
    pub length: libc::c_uint,
    pub sequence: *mut CommandInfo,
}
#[test]
fn bindgen_test_layout__bindgen_ty_37() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_37>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_37>() , 8usize);
}
impl Clone for _bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_37 as CommandInfoList;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_38 {
    pub name: *mut libc::c_char,
    pub writable: AttrWriteType,
    pub data_format: AttrDataFormat,
    pub data_type: TangoDataType,
    pub max_dim_x: libc::c_int,
    pub max_dim_y: libc::c_int,
    pub description: *mut libc::c_char,
    pub label: *mut libc::c_char,
    pub unit: *mut libc::c_char,
    pub standard_unit: *mut libc::c_char,
    pub display_unit: *mut libc::c_char,
    pub format: *mut libc::c_char,
    pub min_value: *mut libc::c_char,
    pub max_value: *mut libc::c_char,
    pub min_alarm: *mut libc::c_char,
    pub max_alarm: *mut libc::c_char,
    pub writable_attr_name: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout__bindgen_ty_38() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_38>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_38>() , 8usize);
}
impl Clone for _bindgen_ty_38 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_38 as AttributeInfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_39 {
    pub length: libc::c_uint,
    pub sequence: *mut AttributeInfo,
}
#[test]
fn bindgen_test_layout__bindgen_ty_39() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_39>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_39>() , 8usize);
}
impl Clone for _bindgen_ty_39 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_39 as AttributeInfoList;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_40 {
    pub property_name: *mut libc::c_char,
    pub data_type: TangoDataType,
    pub prop_data: TangoPropertyData,
    pub is_empty: bool,
    pub wrong_data_type: bool,
}
#[test]
fn bindgen_test_layout__bindgen_ty_40() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_40>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_40>() , 8usize);
}
impl Clone for _bindgen_ty_40 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_40 as DbDatum;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_41 {
    pub length: libc::c_uint,
    pub sequence: *mut DbDatum,
}
#[test]
fn bindgen_test_layout__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_41>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_41>() , 8usize);
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
pub use self::_bindgen_ty_41 as DbData;
extern "C" {
    pub fn tango_create_device_proxy(dev_name: *mut libc::c_char,
                                     proxy: *mut *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_proxy(proxy: *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_timeout_millis(proxy: *mut libc::c_void,
                                    millis: libc::c_int) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_timeout_millis(proxy: *mut libc::c_void,
                                    millis: *mut libc::c_int)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_source(proxy: *mut libc::c_void, source: DevSource)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_source(proxy: *mut libc::c_void, source: *mut DevSource)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_lock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_unlock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked(proxy: *mut libc::c_void, is_locked: *mut bool)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked_by_me(proxy: *mut libc::c_void,
                                 is_locked_by_me: *mut bool)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_locking_status(proxy: *mut libc::c_void,
                                lock_status: *mut *mut libc::c_char)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_query(proxy: *mut libc::c_void,
                               cmd_name: *mut libc::c_char,
                               cmd_info: *mut CommandInfo) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_list_query(proxy: *mut libc::c_void,
                                    cmd_info_list: *mut CommandInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_inout(proxy: *mut libc::c_void,
                               cmd_name: *mut libc::c_char,
                               argin: *mut CommandData,
                               argout: *mut CommandData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_CommandData(command_data: *mut CommandData);
}
extern "C" {
    pub fn tango_free_CommandInfo(command_info: *mut CommandInfo);
}
extern "C" {
    pub fn tango_free_CommandInfoList(command_info_list:
                                          *mut CommandInfoList);
}
extern "C" {
    pub fn tango_get_attribute_list(proxy: *mut libc::c_void,
                                    attr_names: *mut VarStringArray)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_attribute_config(proxy: *mut libc::c_void,
                                      attr_names: *mut VarStringArray,
                                      attr_info_list: *mut AttributeInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_attribute_list_query(proxy: *mut libc::c_void,
                                      attr_info_list: *mut AttributeInfoList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attribute(proxy: *mut libc::c_void,
                                attr_name: *mut libc::c_char,
                                argout: *mut AttributeData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attribute(proxy: *mut libc::c_void,
                                 argin: *mut AttributeData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attributes(proxy: *mut libc::c_void,
                                 attr_names: *mut VarStringArray,
                                 argout: *mut AttributeDataList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attributes(proxy: *mut libc::c_void,
                                  argin: *mut AttributeDataList)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_AttributeData(attribute_data: *mut AttributeData);
}
extern "C" {
    pub fn tango_free_AttributeDataList(attribute_data_list:
                                            *mut AttributeDataList);
}
extern "C" {
    pub fn tango_free_VarStringArray(string_arr: *mut VarStringArray);
}
extern "C" {
    pub fn tango_free_AttributeInfoList(attribute_info_list:
                                            *mut AttributeInfoList);
}
extern "C" {
    pub fn tango_free_ErrorStack(error_stack: *mut ErrorStack);
}
extern "C" {
    pub fn tango_create_database_proxy(db_proxy: *mut *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_database_proxy(db_proxy: *mut libc::c_void)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported(db_proxy: *mut libc::c_void,
                                     name_filter: *mut libc::c_char,
                                     dev_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported_for_class(db_proxy: *mut libc::c_void,
                                               class_name: *mut libc::c_char,
                                               dev_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_list(db_proxy: *mut libc::c_void,
                                 name_filter: *mut libc::c_char,
                                 obj_list: *mut DbDatum) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_property_list(db_proxy: *mut libc::c_void,
                                          obj_name: *mut libc::c_char,
                                          name_filter: *mut libc::c_char,
                                          prop_list: *mut DbDatum)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_property(db_proxy: *mut libc::c_void,
                              obj_name: *mut libc::c_char,
                              prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_property(db_proxy: *mut libc::c_void,
                              obj_name: *mut libc::c_char,
                              prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_property(db_proxy: *mut libc::c_void,
                                 obj_name: *mut libc::c_char,
                                 prop_list: *mut DbData) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_property(dev_proxy: *mut libc::c_void,
                                     prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_device_property(dev_proxy: *mut libc::c_void,
                                     prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_property(dev_proxy: *mut libc::c_void,
                                        prop_list: *mut DbData)
     -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_DbDatum(db_datum: *mut DbDatum);
}
extern "C" {
    pub fn tango_free_DbData(db_data: *mut DbData);
}
