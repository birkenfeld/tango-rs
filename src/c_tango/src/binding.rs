/* automatically generated by rust-bindgen */

pub const _SYS_TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> libc::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> libc::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = libc::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn futimes(__fd: libc::c_int, __tvp: *const timeval) -> libc::c_int;
}
pub type int_least8_t = libc::c_schar;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type TangoDevLong = i32;
pub type TangoDevULong = u32;
pub type TangoDevLong64 = i64;
pub type TangoDevULong64 = u64;
pub const TangoDataType_DEV_VOID: TangoDataType = 0;
pub const TangoDataType_DEV_BOOLEAN: TangoDataType = 1;
pub const TangoDataType_DEV_SHORT: TangoDataType = 2;
pub const TangoDataType_DEV_LONG: TangoDataType = 3;
pub const TangoDataType_DEV_FLOAT: TangoDataType = 4;
pub const TangoDataType_DEV_DOUBLE: TangoDataType = 5;
pub const TangoDataType_DEV_USHORT: TangoDataType = 6;
pub const TangoDataType_DEV_ULONG: TangoDataType = 7;
pub const TangoDataType_DEV_STRING: TangoDataType = 8;
pub const TangoDataType_DEVVAR_CHARARRAY: TangoDataType = 9;
pub const TangoDataType_DEVVAR_SHORTARRAY: TangoDataType = 10;
pub const TangoDataType_DEVVAR_LONGARRAY: TangoDataType = 11;
pub const TangoDataType_DEVVAR_FLOATARRAY: TangoDataType = 12;
pub const TangoDataType_DEVVAR_DOUBLEARRAY: TangoDataType = 13;
pub const TangoDataType_DEVVAR_USHORTARRAY: TangoDataType = 14;
pub const TangoDataType_DEVVAR_ULONGARRAY: TangoDataType = 15;
pub const TangoDataType_DEVVAR_STRINGARRAY: TangoDataType = 16;
pub const TangoDataType_DEVVAR_LONGSTRINGARRAY: TangoDataType = 17;
pub const TangoDataType_DEVVAR_DOUBLESTRINGARRAY: TangoDataType = 18;
pub const TangoDataType_DEV_STATE: TangoDataType = 19;
pub const TangoDataType_CONST_DEV_STRING: TangoDataType = 20;
pub const TangoDataType_DEVVAR_BOOLEANARRAY: TangoDataType = 21;
pub const TangoDataType_DEV_UCHAR: TangoDataType = 22;
pub const TangoDataType_DEV_LONG64: TangoDataType = 23;
pub const TangoDataType_DEV_ULONG64: TangoDataType = 24;
pub const TangoDataType_DEVVAR_LONG64ARRAY: TangoDataType = 25;
pub const TangoDataType_DEVVAR_ULONG64ARRAY: TangoDataType = 26;
pub const TangoDataType_DEV_INT: TangoDataType = 27;
pub const TangoDataType_DEV_ENCODED: TangoDataType = 28;
pub type TangoDataType = u32;
pub const TangoDevState_ON: TangoDevState = 0;
pub const TangoDevState_OFF: TangoDevState = 1;
pub const TangoDevState_CLOSE: TangoDevState = 2;
pub const TangoDevState_OPEN: TangoDevState = 3;
pub const TangoDevState_INSERT: TangoDevState = 4;
pub const TangoDevState_EXTRACT: TangoDevState = 5;
pub const TangoDevState_MOVING: TangoDevState = 6;
pub const TangoDevState_STANDBY: TangoDevState = 7;
pub const TangoDevState_FAULT: TangoDevState = 8;
pub const TangoDevState_INIT: TangoDevState = 9;
pub const TangoDevState_RUNNING: TangoDevState = 10;
pub const TangoDevState_ALARM: TangoDevState = 11;
pub const TangoDevState_DISABLE: TangoDevState = 12;
pub const TangoDevState_UNKNOWN: TangoDevState = 13;
pub type TangoDevState = u32;
pub const AttrQuality_ATTR_VALID: AttrQuality = 0;
pub const AttrQuality_ATTR_INVALID: AttrQuality = 1;
pub const AttrQuality_ATTR_ALARM: AttrQuality = 2;
pub const AttrQuality_ATTR_CHANGING: AttrQuality = 3;
pub const AttrQuality_ATTR_WARNING: AttrQuality = 4;
pub type AttrQuality = u32;
pub const AttrWriteType_READ: AttrWriteType = 0;
pub const AttrWriteType_READ_WITH_WRITE: AttrWriteType = 1;
pub const AttrWriteType_WRITE: AttrWriteType = 2;
pub const AttrWriteType_READ_WRITE: AttrWriteType = 3;
pub type AttrWriteType = u32;
pub const AttrDataFormat_SCALAR: AttrDataFormat = 0;
pub const AttrDataFormat_SPECTRUM: AttrDataFormat = 1;
pub const AttrDataFormat_IMAGE: AttrDataFormat = 2;
pub type AttrDataFormat = u32;
pub const DispLevel_OPERATOR: DispLevel = 0;
pub const DispLevel_EXPERT: DispLevel = 1;
pub type DispLevel = u32;
pub const ErrSeverity_WARN: ErrSeverity = 0;
pub const ErrSeverity_ERR: ErrSeverity = 1;
pub const ErrSeverity_PANIC: ErrSeverity = 2;
pub type ErrSeverity = u32;
pub const DevSource_DEV: DevSource = 0;
pub const DevSource_CACHE: DevSource = 1;
pub const DevSource_CACHE_DEV: DevSource = 2;
pub type DevSource = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TangoDevEncoded {
    pub encoded_format: *mut libc::c_char,
    pub encoded_length: u32,
    pub encoded_data: *mut u8,
}
#[test]
fn bindgen_test_layout_TangoDevEncoded() {
    assert_eq!(
        ::std::mem::size_of::<TangoDevEncoded>(),
        24usize,
        concat!("Size of: ", stringify!(TangoDevEncoded))
    );
    assert_eq!(
        ::std::mem::align_of::<TangoDevEncoded>(),
        8usize,
        concat!("Alignment of ", stringify!(TangoDevEncoded))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoDevEncoded>())).encoded_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoDevEncoded),
            "::",
            stringify!(encoded_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoDevEncoded>())).encoded_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoDevEncoded),
            "::",
            stringify!(encoded_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoDevEncoded>())).encoded_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoDevEncoded),
            "::",
            stringify!(encoded_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarBoolArray {
    pub length: u32,
    pub sequence: *mut bool,
}
#[test]
fn bindgen_test_layout_VarBoolArray() {
    assert_eq!(
        ::std::mem::size_of::<VarBoolArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarBoolArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarBoolArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarBoolArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarBoolArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarBoolArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarBoolArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarBoolArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarCharArray {
    pub length: u32,
    pub sequence: *mut u8,
}
#[test]
fn bindgen_test_layout_VarCharArray() {
    assert_eq!(
        ::std::mem::size_of::<VarCharArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarCharArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarCharArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarCharArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarCharArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarCharArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarCharArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarCharArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarShortArray {
    pub length: u32,
    pub sequence: *mut i16,
}
#[test]
fn bindgen_test_layout_VarShortArray() {
    assert_eq!(
        ::std::mem::size_of::<VarShortArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarShortArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarShortArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarShortArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarShortArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarShortArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarShortArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarShortArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarUShortArray {
    pub length: u32,
    pub sequence: *mut u16,
}
#[test]
fn bindgen_test_layout_VarUShortArray() {
    assert_eq!(
        ::std::mem::size_of::<VarUShortArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarUShortArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarUShortArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarUShortArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarUShortArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarUShortArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarUShortArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarUShortArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarLongArray {
    pub length: u32,
    pub sequence: *mut TangoDevLong,
}
#[test]
fn bindgen_test_layout_VarLongArray() {
    assert_eq!(
        ::std::mem::size_of::<VarLongArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarLongArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarLongArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarLongArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarLongArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarLongArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarULongArray {
    pub length: u32,
    pub sequence: *mut TangoDevULong,
}
#[test]
fn bindgen_test_layout_VarULongArray() {
    assert_eq!(
        ::std::mem::size_of::<VarULongArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarULongArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarULongArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarULongArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarULongArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarULongArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarULongArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarULongArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarLong64Array {
    pub length: u32,
    pub sequence: *mut TangoDevLong64,
}
#[test]
fn bindgen_test_layout_VarLong64Array() {
    assert_eq!(
        ::std::mem::size_of::<VarLong64Array>(),
        16usize,
        concat!("Size of: ", stringify!(VarLong64Array))
    );
    assert_eq!(
        ::std::mem::align_of::<VarLong64Array>(),
        8usize,
        concat!("Alignment of ", stringify!(VarLong64Array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarLong64Array>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLong64Array),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarLong64Array>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLong64Array),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarULong64Array {
    pub length: u32,
    pub sequence: *mut TangoDevULong64,
}
#[test]
fn bindgen_test_layout_VarULong64Array() {
    assert_eq!(
        ::std::mem::size_of::<VarULong64Array>(),
        16usize,
        concat!("Size of: ", stringify!(VarULong64Array))
    );
    assert_eq!(
        ::std::mem::align_of::<VarULong64Array>(),
        8usize,
        concat!("Alignment of ", stringify!(VarULong64Array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarULong64Array>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarULong64Array),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarULong64Array>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarULong64Array),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarFloatArray {
    pub length: u32,
    pub sequence: *mut f32,
}
#[test]
fn bindgen_test_layout_VarFloatArray() {
    assert_eq!(
        ::std::mem::size_of::<VarFloatArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarFloatArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarFloatArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarFloatArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarFloatArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarFloatArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarFloatArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarDoubleArray {
    pub length: u32,
    pub sequence: *mut f64,
}
#[test]
fn bindgen_test_layout_VarDoubleArray() {
    assert_eq!(
        ::std::mem::size_of::<VarDoubleArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarDoubleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarDoubleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarDoubleArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarDoubleArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarDoubleArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarStringArray {
    pub length: u32,
    pub sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarStringArray() {
    assert_eq!(
        ::std::mem::size_of::<VarStringArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarStringArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarStringArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarStringArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarStringArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarStringArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarStateArray {
    pub length: u32,
    pub sequence: *mut TangoDevState,
}
#[test]
fn bindgen_test_layout_VarStateArray() {
    assert_eq!(
        ::std::mem::size_of::<VarStateArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarStateArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarStateArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarStateArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarStateArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarStateArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarStateArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarStateArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarEncodedArray {
    pub length: u32,
    pub sequence: *mut TangoDevEncoded,
}
#[test]
fn bindgen_test_layout_VarEncodedArray() {
    assert_eq!(
        ::std::mem::size_of::<VarEncodedArray>(),
        16usize,
        concat!("Size of: ", stringify!(VarEncodedArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarEncodedArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarEncodedArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarEncodedArray>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarEncodedArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarEncodedArray>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarEncodedArray),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarLongStringArray {
    pub long_length: u32,
    pub long_sequence: *mut TangoDevLong,
    pub string_length: u32,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarLongStringArray() {
    assert_eq!(
        ::std::mem::size_of::<VarLongStringArray>(),
        32usize,
        concat!("Size of: ", stringify!(VarLongStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarLongStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarLongStringArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VarLongStringArray>())).long_length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongStringArray),
            "::",
            stringify!(long_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarLongStringArray>())).long_sequence as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongStringArray),
            "::",
            stringify!(long_sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarLongStringArray>())).string_length as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongStringArray),
            "::",
            stringify!(string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarLongStringArray>())).string_sequence as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VarLongStringArray),
            "::",
            stringify!(string_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VarDoubleStringArray {
    pub double_length: u32,
    pub double_sequence: *mut f64,
    pub string_length: u32,
    pub string_sequence: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_VarDoubleStringArray() {
    assert_eq!(
        ::std::mem::size_of::<VarDoubleStringArray>(),
        32usize,
        concat!("Size of: ", stringify!(VarDoubleStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<VarDoubleStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(VarDoubleStringArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarDoubleStringArray>())).double_length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleStringArray),
            "::",
            stringify!(double_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarDoubleStringArray>())).double_sequence as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleStringArray),
            "::",
            stringify!(double_sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarDoubleStringArray>())).string_length as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleStringArray),
            "::",
            stringify!(string_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VarDoubleStringArray>())).string_sequence as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VarDoubleStringArray),
            "::",
            stringify!(string_sequence)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TangoAttributeData {
    pub bool_arr: VarBoolArray,
    pub char_arr: VarCharArray,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    pub state_arr: VarStateArray,
    pub encoded_arr: VarEncodedArray,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_TangoAttributeData() {
    assert_eq!(
        ::std::mem::size_of::<TangoAttributeData>(),
        16usize,
        concat!("Size of: ", stringify!(TangoAttributeData))
    );
    assert_eq!(
        ::std::mem::align_of::<TangoAttributeData>(),
        8usize,
        concat!("Alignment of ", stringify!(TangoAttributeData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).bool_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(bool_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).char_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(char_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).short_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(short_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).ushort_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(ushort_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).long_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(long_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).ulong_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(ulong_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).long64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(long64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).ulong64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(ulong64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).float_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(float_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).double_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(double_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).string_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(string_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).state_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(state_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoAttributeData>())).encoded_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoAttributeData),
            "::",
            stringify!(encoded_arr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TangoCommandData {
    pub bool_val: bool,
    pub short_val: i16,
    pub ushort_val: u16,
    pub long_val: i32,
    pub ulong_val: u32,
    pub float_val: f32,
    pub double_val: f64,
    pub string_val: *mut libc::c_char,
    pub state_val: TangoDevState,
    pub long64_val: TangoDevLong64,
    pub ulong64_val: TangoDevULong64,
    pub bool_arr: VarBoolArray,
    pub char_arr: VarCharArray,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    pub state_arr: VarStateArray,
    pub encoded_val: TangoDevEncoded,
    pub long_string_arr: VarLongStringArray,
    pub double_string_arr: VarDoubleStringArray,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_TangoCommandData() {
    assert_eq!(
        ::std::mem::size_of::<TangoCommandData>(),
        32usize,
        concat!("Size of: ", stringify!(TangoCommandData))
    );
    assert_eq!(
        ::std::mem::align_of::<TangoCommandData>(),
        8usize,
        concat!("Alignment of ", stringify!(TangoCommandData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).bool_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(bool_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).short_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(short_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ushort_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ushort_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).long_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(long_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ulong_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ulong_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).float_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(float_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).double_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(double_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).string_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(string_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).state_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(state_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).long64_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(long64_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ulong64_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ulong64_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).bool_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(bool_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).char_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(char_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).short_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(short_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ushort_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ushort_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).long_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(long_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ulong_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ulong_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).long64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(long64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).ulong64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(ulong64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).float_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(float_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).double_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(double_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).string_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(string_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).state_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(state_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoCommandData>())).encoded_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(encoded_val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TangoCommandData>())).long_string_arr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(long_string_arr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TangoCommandData>())).double_string_arr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoCommandData),
            "::",
            stringify!(double_string_arr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TangoPropertyData {
    pub bool_val: bool,
    pub char_val: u8,
    pub short_val: i16,
    pub ushort_val: u16,
    pub long_val: i32,
    pub ulong_val: u32,
    pub float_val: f32,
    pub double_val: f64,
    pub string_val: *mut libc::c_char,
    pub long64_val: TangoDevLong64,
    pub ulong64_val: TangoDevULong64,
    pub short_arr: VarShortArray,
    pub ushort_arr: VarUShortArray,
    pub long_arr: VarLongArray,
    pub ulong_arr: VarULongArray,
    pub long64_arr: VarLong64Array,
    pub ulong64_arr: VarULong64Array,
    pub float_arr: VarFloatArray,
    pub double_arr: VarDoubleArray,
    pub string_arr: VarStringArray,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_TangoPropertyData() {
    assert_eq!(
        ::std::mem::size_of::<TangoPropertyData>(),
        16usize,
        concat!("Size of: ", stringify!(TangoPropertyData))
    );
    assert_eq!(
        ::std::mem::align_of::<TangoPropertyData>(),
        8usize,
        concat!("Alignment of ", stringify!(TangoPropertyData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).bool_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(bool_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).char_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(char_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).short_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(short_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ushort_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ushort_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).long_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(long_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ulong_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ulong_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).float_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(float_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).double_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(double_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).string_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(string_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).long64_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(long64_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ulong64_val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ulong64_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).short_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(short_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ushort_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ushort_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).long_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(long_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ulong_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ulong_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).long64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(long64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).ulong64_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(ulong64_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).float_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(float_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).double_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(double_arr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TangoPropertyData>())).string_arr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TangoPropertyData),
            "::",
            stringify!(string_arr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CommandData {
    pub arg_type: TangoDataType,
    pub cmd_data: TangoCommandData,
}
#[test]
fn bindgen_test_layout_CommandData() {
    assert_eq!(
        ::std::mem::size_of::<CommandData>(),
        40usize,
        concat!("Size of: ", stringify!(CommandData))
    );
    assert_eq!(
        ::std::mem::align_of::<CommandData>(),
        8usize,
        concat!("Alignment of ", stringify!(CommandData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandData>())).arg_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandData),
            "::",
            stringify!(arg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandData>())).cmd_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandData),
            "::",
            stringify!(cmd_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AttributeData {
    pub data_type: TangoDataType,
    pub attr_data: TangoAttributeData,
    pub data_format: AttrDataFormat,
    pub quality: AttrQuality,
    pub nb_read: libc::c_long,
    pub name: *mut libc::c_char,
    pub dim_x: i32,
    pub dim_y: i32,
    pub time_stamp: timeval,
}
#[test]
fn bindgen_test_layout_AttributeData() {
    assert_eq!(
        ::std::mem::size_of::<AttributeData>(),
        72usize,
        concat!("Size of: ", stringify!(AttributeData))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeData>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).data_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).attr_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(attr_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).data_format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(data_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).quality as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).nb_read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(nb_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).dim_x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(dim_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).dim_y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(dim_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeData>())).time_stamp as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeData),
            "::",
            stringify!(time_stamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttributeDataList {
    pub length: u32,
    pub sequence: *mut AttributeData,
}
#[test]
fn bindgen_test_layout_AttributeDataList() {
    assert_eq!(
        ::std::mem::size_of::<AttributeDataList>(),
        16usize,
        concat!("Size of: ", stringify!(AttributeDataList))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeDataList>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeDataList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeDataList>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeDataList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeDataList>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeDataList),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DevFailed {
    pub desc: *mut libc::c_char,
    pub reason: *mut libc::c_char,
    pub origin: *mut libc::c_char,
    pub severity: ErrSeverity,
}
#[test]
fn bindgen_test_layout_DevFailed() {
    assert_eq!(
        ::std::mem::size_of::<DevFailed>(),
        32usize,
        concat!("Size of: ", stringify!(DevFailed))
    );
    assert_eq!(
        ::std::mem::align_of::<DevFailed>(),
        8usize,
        concat!("Alignment of ", stringify!(DevFailed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFailed>())).desc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFailed),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFailed>())).reason as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFailed),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFailed>())).origin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFailed),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DevFailed>())).severity as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DevFailed),
            "::",
            stringify!(severity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorStack {
    pub length: u32,
    pub sequence: *mut DevFailed,
}
#[test]
fn bindgen_test_layout_ErrorStack() {
    assert_eq!(
        ::std::mem::size_of::<ErrorStack>(),
        16usize,
        concat!("Size of: ", stringify!(ErrorStack))
    );
    assert_eq!(
        ::std::mem::align_of::<ErrorStack>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorStack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorStack>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorStack),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ErrorStack>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorStack),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandInfo {
    pub cmd_name: *mut libc::c_char,
    pub cmd_tag: i32,
    pub in_type: i32,
    pub out_type: i32,
    pub in_type_desc: *mut libc::c_char,
    pub out_type_desc: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout_CommandInfo() {
    assert_eq!(
        ::std::mem::size_of::<CommandInfo>(),
        48usize,
        concat!("Size of: ", stringify!(CommandInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CommandInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CommandInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).cmd_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(cmd_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).cmd_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(cmd_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).in_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(in_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).out_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(out_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).in_type_desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(in_type_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).out_type_desc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(out_type_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfo>())).disp_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfo),
            "::",
            stringify!(disp_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommandInfoList {
    pub length: u32,
    pub sequence: *mut CommandInfo,
}
#[test]
fn bindgen_test_layout_CommandInfoList() {
    assert_eq!(
        ::std::mem::size_of::<CommandInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(CommandInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<CommandInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(CommandInfoList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfoList>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfoList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CommandInfoList>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CommandInfoList),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttributeInfo {
    pub name: *mut libc::c_char,
    pub writable: AttrWriteType,
    pub data_format: AttrDataFormat,
    pub data_type: TangoDataType,
    pub max_dim_x: i32,
    pub max_dim_y: i32,
    pub description: *mut libc::c_char,
    pub label: *mut libc::c_char,
    pub unit: *mut libc::c_char,
    pub standard_unit: *mut libc::c_char,
    pub display_unit: *mut libc::c_char,
    pub format: *mut libc::c_char,
    pub min_value: *mut libc::c_char,
    pub max_value: *mut libc::c_char,
    pub min_alarm: *mut libc::c_char,
    pub max_alarm: *mut libc::c_char,
    pub writable_attr_name: *mut libc::c_char,
    pub disp_level: DispLevel,
}
#[test]
fn bindgen_test_layout_AttributeInfo() {
    assert_eq!(
        ::std::mem::size_of::<AttributeInfo>(),
        128usize,
        concat!("Size of: ", stringify!(AttributeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).writable as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(writable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).data_format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(data_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).data_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).max_dim_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(max_dim_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).max_dim_y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(max_dim_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).unit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).standard_unit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(standard_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).display_unit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(display_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).format as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).min_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(min_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).max_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(max_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).min_alarm as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(min_alarm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).max_alarm as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(max_alarm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AttributeInfo>())).writable_attr_name as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(writable_attr_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfo>())).disp_level as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfo),
            "::",
            stringify!(disp_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttributeInfoList {
    pub length: u32,
    pub sequence: *mut AttributeInfo,
}
#[test]
fn bindgen_test_layout_AttributeInfoList() {
    assert_eq!(
        ::std::mem::size_of::<AttributeInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(AttributeInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeInfoList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfoList>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfoList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeInfoList>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeInfoList),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DbDatum {
    pub property_name: *mut libc::c_char,
    pub data_type: TangoDataType,
    pub prop_data: TangoPropertyData,
    pub is_empty: bool,
    pub wrong_data_type: bool,
}
#[test]
fn bindgen_test_layout_DbDatum() {
    assert_eq!(
        ::std::mem::size_of::<DbDatum>(),
        40usize,
        concat!("Size of: ", stringify!(DbDatum))
    );
    assert_eq!(
        ::std::mem::align_of::<DbDatum>(),
        8usize,
        concat!("Alignment of ", stringify!(DbDatum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbDatum>())).property_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DbDatum),
            "::",
            stringify!(property_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbDatum>())).data_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DbDatum),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbDatum>())).prop_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DbDatum),
            "::",
            stringify!(prop_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbDatum>())).is_empty as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DbDatum),
            "::",
            stringify!(is_empty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbDatum>())).wrong_data_type as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(DbDatum),
            "::",
            stringify!(wrong_data_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DbData {
    pub length: u32,
    pub sequence: *mut DbDatum,
}
#[test]
fn bindgen_test_layout_DbData() {
    assert_eq!(
        ::std::mem::size_of::<DbData>(),
        16usize,
        concat!("Size of: ", stringify!(DbData))
    );
    assert_eq!(
        ::std::mem::align_of::<DbData>(),
        8usize,
        concat!("Alignment of ", stringify!(DbData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbData>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DbData),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DbData>())).sequence as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DbData),
            "::",
            stringify!(sequence)
        )
    );
}
extern "C" {
    pub fn tango_create_device_proxy(
        dev_name: *mut libc::c_char,
        proxy: *mut *mut libc::c_void,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_proxy(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_timeout_millis(
        proxy: *mut libc::c_void,
        millis: libc::c_int,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_timeout_millis(
        proxy: *mut libc::c_void,
        millis: *mut libc::c_int,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_set_source(proxy: *mut libc::c_void, source: DevSource) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_source(proxy: *mut libc::c_void, source: *mut DevSource) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_lock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_unlock(proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked(proxy: *mut libc::c_void, is_locked: *mut bool) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_is_locked_by_me(
        proxy: *mut libc::c_void,
        is_locked_by_me: *mut bool,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_locking_status(
        proxy: *mut libc::c_void,
        lock_status: *mut *mut libc::c_char,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_query(
        proxy: *mut libc::c_void,
        cmd_name: *mut libc::c_char,
        cmd_info: *mut CommandInfo,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_list_query(
        proxy: *mut libc::c_void,
        cmd_info_list: *mut CommandInfoList,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_command_inout(
        proxy: *mut libc::c_void,
        cmd_name: *mut libc::c_char,
        argin: *mut CommandData,
        argout: *mut CommandData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_CommandData(command_data: *mut CommandData);
}
extern "C" {
    pub fn tango_free_CommandInfo(command_info: *mut CommandInfo);
}
extern "C" {
    pub fn tango_free_CommandInfoList(command_info_list: *mut CommandInfoList);
}
extern "C" {
    pub fn tango_get_attribute_list(
        proxy: *mut libc::c_void,
        attr_names: *mut VarStringArray,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_attribute_config(
        proxy: *mut libc::c_void,
        attr_names: *mut VarStringArray,
        attr_info_list: *mut AttributeInfoList,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_attribute_list_query(
        proxy: *mut libc::c_void,
        attr_info_list: *mut AttributeInfoList,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attribute(
        proxy: *mut libc::c_void,
        attr_name: *mut libc::c_char,
        argout: *mut AttributeData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attribute(
        proxy: *mut libc::c_void,
        argin: *mut AttributeData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_read_attributes(
        proxy: *mut libc::c_void,
        attr_names: *mut VarStringArray,
        argout: *mut AttributeDataList,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_write_attributes(
        proxy: *mut libc::c_void,
        argin: *mut AttributeDataList,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_AttributeData(attribute_data: *mut AttributeData);
}
extern "C" {
    pub fn tango_free_AttributeDataList(attribute_data_list: *mut AttributeDataList);
}
extern "C" {
    pub fn tango_free_VarStringArray(string_arr: *mut VarStringArray);
}
extern "C" {
    pub fn tango_free_AttributeInfoList(attribute_info_list: *mut AttributeInfoList);
}
extern "C" {
    pub fn tango_free_ErrorStack(error_stack: *mut ErrorStack);
}
extern "C" {
    pub fn tango_create_database_proxy(db_proxy: *mut *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_database_proxy(db_proxy: *mut libc::c_void) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported(
        db_proxy: *mut libc::c_void,
        name_filter: *mut libc::c_char,
        dev_list: *mut DbDatum,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_exported_for_class(
        db_proxy: *mut libc::c_void,
        class_name: *mut libc::c_char,
        dev_list: *mut DbDatum,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_list(
        db_proxy: *mut libc::c_void,
        name_filter: *mut libc::c_char,
        obj_list: *mut DbDatum,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_object_property_list(
        db_proxy: *mut libc::c_void,
        obj_name: *mut libc::c_char,
        name_filter: *mut libc::c_char,
        prop_list: *mut DbDatum,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_property(
        db_proxy: *mut libc::c_void,
        obj_name: *mut libc::c_char,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_property(
        db_proxy: *mut libc::c_void,
        obj_name: *mut libc::c_char,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_property(
        db_proxy: *mut libc::c_void,
        obj_name: *mut libc::c_char,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_get_device_property(
        dev_proxy: *mut libc::c_void,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_put_device_property(
        dev_proxy: *mut libc::c_void,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_delete_device_property(
        dev_proxy: *mut libc::c_void,
        prop_list: *mut DbData,
    ) -> *mut ErrorStack;
}
extern "C" {
    pub fn tango_free_DbDatum(db_datum: *mut DbDatum);
}
extern "C" {
    pub fn tango_free_DbData(db_data: *mut DbData);
}
